@import('Foundation/NSLog');
@import('Foundation/NSString');
@import('Foundation/NSTimer');
@import('Foundation/NSRunLoop');
@import('Foundation/NSDefaultRunLoopMode');
@import('Foundation/NSDate');
@import('UIKit/UIApplication');
@import('UIKit/UIColor');
@import('UIKit/UIScreen');
@import('UIKit/UIView');
@import('CoreGraphics/CGRectMake');
@import('QuartzCore/CADisplayLink');

const TARGET_FPS = 100,
	CELL_SIZE = 4,
	screenSize = UIScreen.mainScreen().bounds.size,
	height = screenSize.height,
	width = screenSize.width,
	xSize = width / CELL_SIZE,
	ySize = height / CELL_SIZE;

// shorthand for using NSLog
var console = {
	log: function(s) { NSLog(NSString.stringWithUTF8String('%@'), s); },
	debug: function(s) { DEBUG && console.log(s); }
};

// set the FPS and rendering functions based on CLI args
var getFPS, render, lastTime;
if (typeof TITANIUM_LINK !== 'undefined') {
	lastTime = 0;
	getFPS = function(sender) {
		var fps = Math.ceil(1.0 / (sender.timestamp - lastTime));
		lastTime = sender.timestamp;
		return fps;
	};
	render = function(callback) {
		console.debug('>>>>> Using CADisplayLink for render loop <<<<<');

		// create a display link, using the render loop update function
		var displayLink = CADisplayLink.displayLinkWithTarget(callback, 'update:');

		// attach the display link to the main run loop
		displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), NSDefaultRunLoopMode);
	};
} else {
	lastTime = NSDate.date();
	getFPS = function(sender) {
		var fps = Math.ceil(1.0 / -lastTime.timeIntervalSinceNow());
		lastTime = NSDate.date();
		return fps;
	};
	render = function(callback) {
		console.debug('>>>>> Using NSTimer for render loop <<<<<');

		// launch timer with TimerCallback as its target/selector
		var timer = NSTimer.scheduledTimerWithTimeInterval(
			1.0/TARGET_FPS, callback, 'update:', null, true);
	};
}

// calculate the next state of each cell
function getNextState(x, y, alive) {
	var count = 0,
		xm1 = x > 0,
		xp1 = x+1 < xSize,
		ym1 = y > 0,
		yp1 = y+1 < ySize;

	if (xm1) {
		if (ym1 && cells[x-1][y-1].lastAlive) { count++; }
		if (cells[x-1][y].lastAlive) { count++; }
		if (yp1 && cells[x-1][y+1].lastAlive) { count++; }
	}
	if (xp1) {
		if (ym1 && cells[x+1][y-1].lastAlive) { count++; }
		if (cells[x+1][y].lastAlive) { count++; }
		if (yp1 && cells[x+1][y+1].lastAlive) { count++; }
	}
	if (ym1 && cells[x][y-1].lastAlive) { count++; }
	if (yp1 && cells[x][y+1].lastAlive) { count++; }

	return (alive && (count === 2 || count === 3)) || (!alive && count === 3);
}

// configure main window
var keyWindow = UIApplication.sharedApplication().keyWindow;
keyWindow.backgroundColor = UIColor.blackColor();

// seed the grid
var cells = [];
for (var x = 0; x < xSize; x++) {

	cells[x] = [];
	for (var y = 0; y < ySize; y++) {
		// determine whether or not this cell is alive
		var alive = Math.random() >= 0.5;

		// create a native UIView
		var cellProxy = new UIView();
		cellProxy.frame = CGRectMake(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
		cellProxy.backgroundColor = UIColor.whiteColor();
		cellProxy.setHidden(!alive);

		// save the cell
		cells[x][y] = {
			proxy: cellProxy,
			lastAlive: alive,
			alive: alive
		};

		// add the cell to the window
		keyWindow.addSubview(cellProxy);
	}
}

// the render function
function update(params) {
	var x, y, cell;

	// render current generation
	for (x = 0; x < xSize; x++) {
		for (y = 0; y < ySize; y++) {
			cell = cells[x][y];

			// minimze number of times we need to modify the proxy object
			if (cell.alive !== cell.lastAlive) {
				cell.proxy.setHidden(!cell.alive);
			}

			// save the state
			cell.lastAlive = cell.alive;
		}
	}

	// build next generation
	for (x = 0; x < xSize; x++) {
		for (y = 0; y < ySize; y++) {
			cell = cells[x][y];
			cell.alive = getNextState(x, y, cell.lastAlive);
		}
	}

	// show the average FPS
	console.log('FPS: ' + getFPS(params.sender));

}

// Implement a class for our render loop update
@class('RenderCallback', NSObject, [], [
	{
		name: 'update',
		returnType: 'void',
		arguments: [{type:'id',name:'sender'}],
		action: update
	}
]);

// Let's do this
render(new RenderCallback());
