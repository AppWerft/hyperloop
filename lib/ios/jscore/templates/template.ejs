/**
 * @preserve This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 * 
 * WARNING: this file is generated and will be overwritten
 * It was generated from <%=gen.filename%> on <%=new Date%>
 */
@import JavaScriptCore;
<% gen.imports.forEach(function(p) { -%>
@import <%=p%>;
<% }) -%>
<% gen.includes.forEach(function(h) { -%>
#import <<%=h%>>
<% }) -%>


// implementations define this
extern NSData* decompressBuffer (NSData*);


@interface <%=gen.prefix%><%=gen.name%> : NSObject
+(JSValue*)load:(JSContext*)context;
@end

@implementation <%=gen.prefix%><%=gen.name%> 

+(NSData*)buffer
{
	static UInt8 data[] = { 
		<%=gen.jsBuffer %> 
	};
	return [NSData dataWithBytes:((void*)data) length:<%=gen.jsBuffer.length%>];
}

+(JSValue*)load:(JSContext*)context
{
	@autoreleasepool 
	{
		JSValue *globalObject = [context globalObject];

		// holds a dictionary of all our loaded modules
		JSValue *moduleCache = globalObject[@"$modules"];
		if (moduleCache==nil || ![moduleCache isObject])
		{
			moduleCache = [JSValue valueWithNewObjectInContext:context];
		    [globalObject defineProperty:@"$modules" descriptor:@{
		       JSPropertyDescriptorValueKey: moduleCache,
		       JSPropertyDescriptorWritableKey: @NO,
		       JSPropertyDescriptorEnumerableKey: @NO,
		       JSPropertyDescriptorConfigurableKey: @YES
		    }];
		}
		else 
		{
			// if we're trying to load again, we always must return
			// the same reference to the module exports
			JSValue *result = moduleCache[@"<%=gen.name%>"];
			if (result!=nil && [result isObject])
			{
				return result;
			}
		}

		JSValue *object = [JSValue valueWithNewObjectInContext:context];
		NSData *compressedBuf = [<%=gen.prefix%><%=gen.name%> buffer];
		NSString *jscode;
		if ([compressedBuf length]==1) 
		{
			// if empty, just evaluate empty JS string
			jscode = @"";
		}
		else 
		{
			NSData *buffer = decompressBuffer(compressedBuf);
	    	jscode = [[NSString alloc] initWithData:buffer encoding:NSUTF8StringEncoding];
		}
    	JSValue *module = [JSValue valueWithNewObjectInContext:context];
    	JSValue *exports = [JSValue valueWithNewObjectInContext:context];

    	object[@"module"] = module;
    	// module.exports is an alias to exports
    	object[@"exports"] = exports;
    	object[@"__dirname"] = @"<%=gen.dirname%>";
    	object[@"__filename"] = @"<%=gen.filename%>";

    	// relative require implementation which takes into account this modules path
    	// so you can relatively load a module
    	id (^require)(NSString *) = ^(NSString *path)
    	{
    		if ([path hasPrefix:@"./"])
    		{
    			path = [NSString stringWithFormat:@"<%=gen.dirname%>%@",[path substringFromIndex:2]];
    		}
    		if ([path hasPrefix:@"/"])
    		{
    			path = [path substringFromIndex:1];
    		}
<% if (gen.dirname!=='/') { -%>
			if ([path hasPrefix:@"<%=gen.dirname%>"]==NO) 
			{
<% if (gen.dirname.charAt(0)==='/') { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname.substring(1)%>/%@", path];
<% } else { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname%>/%@", path];
<% } %>			}
<% } %>			   		
    		NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"[\\s-\\/]" options:NSRegularExpressionCaseInsensitive error:nil];
    		NSString *cn = [regex stringByReplacingMatchesInString:path options:0 range:NSMakeRange(0, [path length]) withTemplate:@"_"];
    		Class cls = NSClassFromString([NSString stringWithFormat:@"<%=gen.prefix%>%@",cn]);
    		if (cls==nil) 
    		{
    			NSString *err = [NSString stringWithFormat:@"couldn't find module named: %@",path];
    			[JSContext currentContext].exception = [JSValue valueWithNewErrorFromMessage:err inContext:[JSContext currentContext]];
    			NSLog(@"[ERROR] %@",err);
    			return (id)nil;
    		}
    		return [cls performSelector:@selector(load:) withObject:context];
    	};	

    	// make our local require function as part of what we're going to expose local scope
    	object[@"require"] = require;

    	module[@"exports"] = exports;
    	module[@"filename"] = @"<%=gen.filename%>";
    	module[@"id"] = @"<%=gen.name%>";
<% var mapvarargfns = []; -%>
<% Object.keys(gen.statics).forEach(function(s) { -%>
		<%if (!gen.statics[s].ref.vararg) { %>

		// <%=gen.statics[s].node.start.line%>:<%=gen.statics[s].node.start.line%> => <%-: gen.statics[s].source | source -%>
		object[@"<%=s%>"] = <%=gen.generateStatic(gen.ast,gen.statics[s],'		')%>;
		<% } else { -%>

		// <%=gen.statics[s].node.start.line%>:<%=gen.statics[s].node.start.line%> => <%- gen.statics[s].source %>
		object[@"<%=s%>"] = ^{
			NSArray *args = [JSContext currentArguments];
<% Object.keys(gen.functions).forEach(function(f) { -%>
<% var fns = gen.functions[f];  fns.forEach(function(fn) { -%>
	<% if (fn.varargSymbol && fn.varargSymbol.indexOf(s+'$')===0 && mapvarargfns.indexOf(fn.varargSymbol)===-1) { -%>
		<% mapvarargfns.push(fn.varargSymbol); -%>

			// vardiac function with <%= fn.varargCount %> arguments
			if ([args count]==<%=fn.varargCount%>) 
			{
				<%= fn.varargResult ? 'return ' : ''%> <%= f %>(<%= gen.currentArgument(fn.varargCount,'args') %>);
			}
	<% } -%>
<% }) -%>
<% }) -%>
	};
		<% } -%>
<% }) -%>
<% Object.keys(gen.classes).forEach(function(c) { %>
		// <%=gen.classes[c].node.start.line%>:<%=gen.classes[c].node.start.line%> => <%-: gen.classes[c].source | source -%>
		object[@"<%=c%>"] = [<%=c%> class];

<% }) -%>
<% Object.keys(gen.constructors).forEach(function(c) { -%>
		// <%=gen.constructors[c].node.start.line%>:<%=gen.constructors[c].node.start.line%> => <%-: gen.constructors[c].source | source -%>
		object[@"<%=c%>$Class"] = ^{
			return [[<%=c%> alloc] init];
		};
	
<% }) -%>

		// turn our JS object into a dictionary so we can get the keys, values
		NSDictionary *dict = [object toDictionary];
		NSArray *keys = [dict allKeys];
		NSString *argStr = [keys componentsJoinedByString:@","];
		NSArray *values = [dict allValues];

		// make the common JS function wrapper, we pass in the variable names we're exposing to
		// the local scope and then will invoke the function with those values
    	NSString *commonJS = [NSString stringWithFormat:@"(function(%@){ %@ ; return exports; })", argStr, jscode];
		JSValue *jsValue = [context evaluateScript:commonJS];
		JSValue *result = [jsValue callWithArguments:values];

		// stick the results of what we've exported into our cache so that when you attempt
		// to load the module again, you'll get the cached exports
		moduleCache[@"<%=gen.name%>"] = result;

		return result;
	}
}

@end
