/**
 * @preserve This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 * 
 * WARNING: this file is generated and will be overwritten
 * It was generated from <%=gen.filename%> on <%=new Date%>
 */
@import JavaScriptCore;
<% gen.imports.forEach(function(p) { -%>
@import <%=p%>;
<% }) -%>
<% gen.includes.forEach(function(h) { -%>
#import <<%=h%>>
<% }) -%>


// implementations define this
extern NSData* decompressBuffer (NSData*);


@interface Ti$<%=gen.name%> : NSObject
+(JSValue*)load:(JSContext*)context;
@end

@implementation Ti$<%=gen.name%> 

+(NSData*)buffer
{
	static UInt8 data[] = { 
		<%=gen.jsBuffer %> 
	};
	return [NSData dataWithBytes:((void*)data) length:<%=gen.jsBuffer.length%>];
}

+(JSValue*)load:(JSContext*)context
{
	@autoreleasepool 
	{
		JSValue *globalObject = [context globalObject];

		// holds a dictionary of all our loaded modules
		JSValue *moduleCache = globalObject[@"$modules"];
		if (moduleCache==nil || ![moduleCache isObject])
		{
			moduleCache = [JSValue valueWithNewObjectInContext:context];
		    [globalObject defineProperty:@"$modules" descriptor:@{
		       JSPropertyDescriptorValueKey: moduleCache,
		       JSPropertyDescriptorWritableKey: @NO,
		       JSPropertyDescriptorEnumerableKey: @NO,
		       JSPropertyDescriptorConfigurableKey: @YES
		    }];
		}
		else 
		{
			// if we're trying to load again, we always must return
			// the same reference to the module exports
			JSValue *result = moduleCache[@"<%=gen.name%>"];
			if (result!=nil && [result isObject])
			{
				return result;
			}
		}

		JSValue *object = [JSValue valueWithNewObjectInContext:context];
		NSData *compressedBuf = [Ti$<%=gen.name%> buffer];
		NSString *jscode;
		if ([compressedBuf length]==1) 
		{
			// if empty, just evaluate empty JS string
			jscode = @"";
		}
		else 
		{
			NSData *buffer = decompressBuffer(compressedBuf);
	    	jscode = [[NSString alloc] initWithData:buffer encoding:NSUTF8StringEncoding];
		}
    	JSValue *module = [JSValue valueWithNewObjectInContext:context];
    	JSValue *exports = [JSValue valueWithNewObjectInContext:context];

    	object[@"module"] = module;
    	object[@"exports"] = exports;
    	object[@"__dirname"] = @"<%=gen.dirname%>";
    	object[@"__filename"] = @"<%=gen.filename%>";

    	// relative require implementation
    	id (^require)(NSString *) = ^(NSString *path)
    	{
    		if ([path hasPrefix:@"./"])
    		{
    			path = [NSString stringWithFormat:@"<%=gen.dirname%>%@",[path substringFromIndex:2]];
    		}
    		if ([path hasPrefix:@"/"])
    		{
    			path = [path substringFromIndex:1];
    		}
    		NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"[\\s-\\/]" options:NSRegularExpressionCaseInsensitive error:nil];
    		NSString *cn = [regex stringByReplacingMatchesInString:path options:0 range:NSMakeRange(0, [path length]) withTemplate:@"_"];
    		Class cls = NSClassFromString([NSString stringWithFormat:@"Ti$%@",cn]);
    		if (cls==nil) 
    		{
    			NSString *err = [NSString stringWithFormat:@"couldn't find module named: %@",path];
    			[JSContext currentContext].exception = [JSValue valueWithNewErrorFromMessage:err inContext:[JSContext currentContext]];
    			NSLog(@"[ERROR] %@",err);
    			return (id)nil;
    		}
    		return [cls performSelector:@selector(load:) withObject:context];
    	};	

    	object[@"require"] = require;
    	module[@"exports"] = exports;
    	module[@"filename"] = @"<%=gen.filename%>";
    	module[@"id"] = @"<%=gen.name%>";

<% var varargfns = [], mapvarargfns = []; -%>
<% Object.keys(gen.functions).forEach(function(f) { -%>
<% var fns = gen.functions[f];  fns.forEach(function(fn) { -%>
	<% if (fn.varargSymbol && varargfns.indexOf(fn.varargSymbol)===-1) { -%>
		<% varargfns.push(fn.varargSymbol); -%>
// <%=f%> with <%=fn.varargCount%> arguments
		<%-: fn.varargBody | source:'		' %>
		object[@"<%=fn.varargSymbol%>"] = <%=fn.varargSymbol%>;

	<% } -%>
<% }) -%>
<% }) -%>
<% Object.keys(gen.statics).forEach(function(s) { -%>
		<%if (!gen.statics[s].ref.vararg) { -%>
		// <%=gen.statics[s].node.start.line%>:<%=gen.statics[s].node.start.line%> => <%-: gen.statics[s].source | source -%>
		object[@"<%=s%>"] = <%=gen.generateStatic(gen.ast,gen.statics[s],'		')%>;
		<% } else { -%>
// <%=gen.statics[s].node.start.line%>:<%=gen.statics[s].node.start.line%> => <%-: gen.statics[s].source | source -%>
		object[@"<%=s%>"] = ^{
		NSArray *args = [JSContext currentArguments];
<% Object.keys(gen.functions).forEach(function(f) { -%>
<% var fns = gen.functions[f];  fns.forEach(function(fn) { -%>
	<% if (fn.varargSymbol && fn.varargSymbol.indexOf(s+'$')===0 && mapvarargfns.indexOf(fn.varargSymbol)===-1) { -%>
		<% mapvarargfns.push(fn.varargSymbol); -%>
// vardiac function with <%= fn.varargCount %> arguments
			if ([args count]==<%=fn.varargCount%>) 
			{
				<%= fn.varargResult ? 'return ' : ''%> <%= fn.varargSymbol %>(<%= gen.currentArgument(fn.varargCount,'args') %>);
			}
	<% } -%>
<% }) -%>
<% }) -%>
};
		<% } -%>

<% }) -%>
<% Object.keys(gen.classes).forEach(function(c) { -%>
		// <%=gen.classes[c].node.start.line%>:<%=gen.classes[c].node.start.line%> => <%-: gen.classes[c].source | source -%>
		object[@"<%=c%>"] = [<%=c%> class];

<% }) -%>
<% Object.keys(gen.constructors).forEach(function(c) { -%>
		// <%=gen.constructors[c].node.start.line%>:<%=gen.constructors[c].node.start.line%> => <%-: gen.constructors[c].source | source -%>
		object[@"<%=c%>$Class"] = ^{
			return [[<%=c%> alloc] init];
		};
	
<% }) -%>

		NSDictionary *dict = [object toDictionary];
		NSArray *keys = [dict allKeys];
		NSString *argStr = [keys componentsJoinedByString:@","];
		NSArray *values = [dict allValues];

    	NSString *commonJS = [NSString stringWithFormat:@"(function(%@){ %@ ; return exports; })", argStr, jscode];
		JSValue *jsValue = [context evaluateScript:commonJS];
		JSValue *result = [jsValue callWithArguments:values];

		// stick it in our module cache
		moduleCache[@"<%=gen.name%>"] = result;

		return result;
	}
}

@end
