/**
 * @preserve This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 *
 * WARNING: this file is generated and will be overwritten
 * It was generated from <%=gen.filename%> on <%=new Date%>
 */
<% Object.keys(symbols).forEach(function(f) { -%>
#import "<%=f%>/<%=f%>_globals.h"
<% }) -%>
<% frameworks.forEach(function(fw) { -%>
@import <%=fw%>;
<% }) -%>
@import JavaScriptCore;
#import <hyperloop.h>

<% Object.keys(gen.classes).forEach(function(c) {
	var cls = gen.classes[c];
-%>
extern JSObjectRef MakeObjectFor<%=c%>Constructor(JSContextRef);
<% }) -%>

// implementations define this
extern NSData* decompressBuffer (NSData*);


@interface <%=gen.prefix%><%=gen.name%> : NSObject
+(JSValue*)load:(JSContext*)context;
@end

@implementation <%=gen.prefix%><%=gen.name%>

+(NSData*)buffer
{
	static UInt8 data[] = {
		<%=gen.jsBuffer %>
	};
	return [NSData dataWithBytes:((void*)data) length:<%=gen.jsBuffer.length%>];
}

+(JSValue*)load:(JSContext*)context
{

	@autoreleasepool
	{
		JSGlobalContextRef contextRef = [context JSGlobalContextRef];
		JSValue *globalObject = [context globalObject];
		JSObjectRef globalObjectRef = JSValueToObject(contextRef,[globalObject JSValueRef],0);

<%if (gen.requires_JSBuffer) { -%>
		// register our JSBuffer if required
		RegisterJSBuffer(contextRef, globalObjectRef);
<%} -%>

		// holds a dictionary of all our loaded modules
		JSValue *moduleCache = globalObject[@"$modules"];
		if (moduleCache==nil || ![moduleCache isObject])
		{
			moduleCache = [JSValue valueWithNewObjectInContext:context];
		    [globalObject defineProperty:@"$modules" descriptor:@{
		       JSPropertyDescriptorValueKey: moduleCache,
		       JSPropertyDescriptorWritableKey: @NO,
		       JSPropertyDescriptorEnumerableKey: @NO,
		       JSPropertyDescriptorConfigurableKey: @YES
		    }];
		}
		else
		{
			// if we're trying to load again, we always must return
			// the same reference to the module exports
			JSValue *result = moduleCache[@"<%=gen.name%>"];
			if (result!=nil && [result isObject])
			{
				return result;
			}
		}

		JSValue *object = [JSValue valueWithNewObjectInContext:context];
		NSData *compressedBuf = [<%=gen.prefix%><%=gen.name%> buffer];
		NSString *jscode;
		if ([compressedBuf length]==1)
		{
			// if empty, just evaluate empty JS string
			jscode = @"";
		}
		else
		{
			NSData *buffer = decompressBuffer(compressedBuf);
	    	jscode = [[[NSString alloc] initWithData:buffer encoding:NSUTF8StringEncoding] autorelease];
		}
    	JSValue *module = [JSValue valueWithNewObjectInContext:context];
    	JSValue *exports = [JSValue valueWithNewObjectInContext:context];

    	object[@"module"] = module;
    	// module.exports is an alias to exports
    	object[@"exports"] = exports;
    	object[@"__dirname"] = @"<%=gen.dirname%>";
    	object[@"__filename"] = @"<%=gen.filename%>";

    	// relative require implementation which takes into account this modules path
    	// so you can relatively load a module
    	id (^require)(NSString *) = ^(NSString *path)
    	{
    		if ([path hasPrefix:@"./"])
    		{
    			path = [NSString stringWithFormat:@"<%=gen.dirname%>%@",[path substringFromIndex:2]];
    		}
    		if ([path hasPrefix:@"/"])
    		{
    			path = [path substringFromIndex:1];
    		}
<% if (gen.dirname!=='/') { -%>
			if ([path hasPrefix:@"<%=gen.dirname%>"]==NO)
			{
<% if (gen.dirname.charAt(0)==='/') { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname.substring(1)%>/%@", path];
<% } else { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname%>/%@", path];
<% } %>			}
<% } %>
    		NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"[\\s-\\/]" options:NSRegularExpressionCaseInsensitive error:nil];
    		NSString *cn = [regex stringByReplacingMatchesInString:path options:0 range:NSMakeRange(0, [path length]) withTemplate:@"_"];
    		Class cls = NSClassFromString([NSString stringWithFormat:@"<%=gen.prefix%>%@",cn]);
    		if (cls==nil)
    		{
    			NSString *err = [NSString stringWithFormat:@"couldn't find module named: %@",path];
    			[JSContext currentContext].exception = [JSValue valueWithNewErrorFromMessage:err inContext:[JSContext currentContext]];
    			NSLog(@"[ERROR] %@",err);
    			return (id)nil;
    		}
    		return [cls performSelector:@selector(load:) withObject:context];
    	};

    	// make our local require function as part of what we're going to expose local scope
    	object[@"require"] = require;

    	module[@"exports"] = exports;
    	module[@"filename"] = @"<%=gen.filename%>";
    	module[@"id"] = @"<%=gen.name%>";

<% Object.keys(gen.classes).forEach(function(c) { %>
		// <%=gen.classes[c].node.start.line%>:<%=gen.classes[c].node.start.line%> => <%-: gen.classes[c].source | source -%>
		JSObjectRef <%=c%>ObjectRef = MakeObjectFor<%=c%>Constructor(contextRef);
		JSStringRef <%=c%>PropStr = JSStringCreateWithUTF8CString("<%=c%>");
    	JSObjectSetProperty(contextRef, globalObjectRef, <%=c%>PropStr, <%=c%>ObjectRef, 0, 0);
    	JSStringRelease(<%=c%>PropStr);
<% }) -%>

<% Object.keys(symbols).forEach(function(f) {
	Object.keys(symbols[f]).forEach(function(sym) {
		var symbol = symbols[f][sym];
-%>
		JSStringRef <%=sym%>name = JSStringCreateWithUTF8CString("<%=sym%>");
		JSObjectRef <%=sym%>ObjectRef = JSObjectMakeFunctionWithCallback(contextRef,<%=sym%>name,<%=sym%>For<%=f%>);
    	JSObjectSetProperty(contextRef, globalObjectRef, <%=sym%>name, <%=sym%>ObjectRef, 0, 0);
		JSStringRelease(<%=sym%>name);
<% }) -%>
<% }) -%>

<% Object.keys(gen.constructors).forEach(function(c) { -%>
		// <%=gen.constructors[c].node.start.line%>:<%=gen.constructors[c].node.start.line%> => <%-: gen.constructors[c].source | source -%>

		object[@"<%=c%>$Class"] = globalObject[@"<%=c%>"];

<% }) -%>

		// turn our JS object into a dictionary so we can get the keys, values
		NSDictionary *dict = [object toDictionary];
		NSArray *keys = [dict allKeys];
		NSString *argStr = [keys componentsJoinedByString:@","];
		NSArray *values = [dict allValues];

		// make the common JS function wrapper, we pass in the variable names we're exposing to
		// the local scope and then will invoke the function with those values

    	NSString *commonJS = [NSString stringWithFormat:@"(function(%@){ %@ ; return exports; })", argStr, jscode];

		JSValue *jsValue = [context evaluateScript:commonJS];
		JSValue *result = [jsValue callWithArguments:values];

		// stick the results of what we've exported into our cache so that when you attempt
		// to load the module again, you'll get the cached exports
		moduleCache[@"<%=gen.name%>"] = result;

		return result;
	}
}

@end
