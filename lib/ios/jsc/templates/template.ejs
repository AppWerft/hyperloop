/**
 * @preserve This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 *
 * WARNING: this file is generated and will be overwritten
 * It was generated from <%=gen.filename%> on <%=new Date%>
 */
<% Object.keys(symbols).forEach(function(f) { -%>
#import "js_<%=f%>/<%=f%>_globals.h"
<% }) -%>
<% frameworks.forEach(function(fw) { -%>
@import <%=fw%>;
<% }) -%>
<% imports.forEach(function(fw) { -%>
@import <%=fw%>;
<% }) -%>
@import JavaScriptCore;
#import <hyperloop.h>

// types we use
<% makers.forEach(function(name) {
	m = metadata.classes[name] || metadata.protocols[name],
	p = m.metatype=='protocol';
-%>
<% if(p){ -%>
extern JSObjectRef MakeObjectFor<%=name%>(JSContextRef, id<<%=name%>>);
<% } else { -%>
extern JSObjectRef MakeObjectFor<%=name%>(JSContextRef, <%=name%>*);
<% } -%>
<% }) %>

<% Object.keys(gen.classes).forEach(function(c) {
	var cls = gen.classes[c],
		isInterface = cls && cls.ref && cls.ref.metatype==='interface';
	if (!isInterface) return;
-%>
extern JSObjectRef MakeObjectFor<%=c%>Constructor(JSContextRef);
<% }) -%>
<% Object.keys(gen.customclasses).forEach(function(c) {
		var classdef = gen.customclasses[c];
	-%>
extern JSObjectRef MakeObjectFor<%=classdef.className%>Constructor(JSContextRef,JSObjectRef);
<% }) -%>

// implementations define this
extern NSData* decompressBuffer (NSData*);


@interface <%=gen.prefix%><%=gen.name%> : NSObject
+(JSValue*)load:(JSContext*)context;
@end

@implementation <%=gen.prefix%><%=gen.name%>

+(NSData*)buffer
{
	static UInt8 data[] = {
		<%=gen.jsBuffer %>
	};
	return [NSData dataWithBytes:((void*)data) length:<%=gen.jsBuffer.length%>];
}

+(JSValue*)load:(JSContext*)context
{

	@autoreleasepool
	{
		JSGlobalContextRef contextRef = [context JSGlobalContextRef];
		JSContextRef ctx = contextRef;
		JSValue *globalObject = [context globalObject];
		JSObjectRef globalObjectRef = JSValueToObject(contextRef,[globalObject JSValueRef],0);

<%if (gen.requires_JSBuffer) { -%>
		// register our JSBuffer if required
		RegisterJSBuffer(contextRef, globalObjectRef);
<%} -%>

		// holds a dictionary of all our loaded modules
		JSValue *moduleCache = globalObject[@"$modules"];
		if (moduleCache==nil || ![moduleCache isObject])
		{
			moduleCache = [JSValue valueWithNewObjectInContext:context];
		    [globalObject defineProperty:@"$modules" descriptor:@{
		       JSPropertyDescriptorValueKey: moduleCache,
		       JSPropertyDescriptorWritableKey: @NO,
		       JSPropertyDescriptorEnumerableKey: @NO,
		       JSPropertyDescriptorConfigurableKey: @YES
		    }];
		}
		else
		{
			// if we're trying to load again, we always must return
			// the same reference to the module exports
			JSValue *result = moduleCache[@"<%=gen.name%>"];
			if (result!=nil && [result isObject])
			{
				return result;
			}
		}

		JSValue *object = [JSValue valueWithNewObjectInContext:context];
		NSData *compressedBuf = [<%=gen.prefix%><%=gen.name%> buffer];
		NSString *jscode;
		if ([compressedBuf length]==1)
		{
			// if empty, just evaluate empty JS string
			jscode = @"";
		}
		else
		{
			NSData *buffer = decompressBuffer(compressedBuf);
	    	jscode = [[[NSString alloc] initWithData:buffer encoding:NSUTF8StringEncoding] autorelease];
		}
    	JSValue *module = [JSValue valueWithNewObjectInContext:context];
    	JSValue *exports = [JSValue valueWithNewObjectInContext:context];

    	object[@"module"] = module;
    	// module.exports is an alias to exports
    	object[@"exports"] = exports;
    	object[@"__dirname"] = @"<%=gen.dirname%>";
    	object[@"__filename"] = @"<%=gen.filename%>";

    	// relative require implementation which takes into account this modules path
    	// so you can relatively load a module
    	id (^require)(NSString *) = ^(NSString *path)
    	{
    		if ([path hasPrefix:@"./"])
    		{
    			path = [NSString stringWithFormat:@"<%=gen.dirname%>%@",[path substringFromIndex:2]];
    		}
    		if ([path hasPrefix:@"/"])
    		{
    			path = [path substringFromIndex:1];
    		}
<% if (gen.dirname!=='/') { -%>
			if ([path hasPrefix:@"<%=gen.dirname%>"]==NO)
			{
<% if (gen.dirname.charAt(0)==='/') { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname.substring(1)%>/%@", path];
<% } else { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname%>/%@", path];
<% } %>			}
<% } %>
    		NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"[\\s-\\/]" options:NSRegularExpressionCaseInsensitive error:nil];
    		NSString *cn = [regex stringByReplacingMatchesInString:path options:0 range:NSMakeRange(0, [path length]) withTemplate:@"_"];
    		Class cls = NSClassFromString([NSString stringWithFormat:@"<%=gen.prefix%>%@",cn]);
    		if (cls==nil)
    		{
    			NSString *err = [NSString stringWithFormat:@"couldn't find module named: %@",path];
    			[JSContext currentContext].exception = [JSValue valueWithNewErrorFromMessage:err inContext:[JSContext currentContext]];
    			NSLog(@"[ERROR] %@",err);
    			return (id)nil;
    		}
    		return [cls performSelector:@selector(load:) withObject:context];
    	};

    	// make our local require function as part of what we're going to expose local scope
    	object[@"require"] = require;

    	module[@"exports"] = exports;
    	module[@"filename"] = @"<%=gen.filename%>";
    	module[@"id"] = @"<%=gen.name%>";

<% Object.keys(gen.classes).forEach(function(c) {
	var cls = gen.classes[c],
		intf = cls && cls.ref,
		isInterface = intf && intf.metatype==='interface';
	if (!isInterface) return;
%>
		// <%=gen.classes[c].node.start.line%>:<%=gen.classes[c].node.start.line%> => <%-: gen.classes[c].source | source -%>
		JSObjectRef <%=c%>ObjectRef = MakeObjectFor<%=c%>Constructor(contextRef);
		JSStringRef <%=c%>PropStr = JSStringCreateWithUTF8CString("<%=c%>");
    	JSObjectSetProperty(contextRef, globalObjectRef, <%=c%>PropStr, <%=c%>ObjectRef, 0, 0);
    	JSStringRelease(<%=c%>PropStr);
<% }) -%>

		// constants
<% Object.keys(constants).forEach(function(n) {
	var symbol = constants[n]; -%>

		JSStringRef <%=n%>$name = JSStringCreateWithUTF8CString("<%=n%>");
		JSValueRef <%=n%>$ValueRef = JSValueMakeNumber(contextRef,<%=symbol.value%>);
		JSValueRef <%=n%>$ObjectRef = JSValueToObject(contextRef,<%=n%>$ValueRef,0);
    	JSObjectSetProperty(contextRef, globalObjectRef, <%=n%>$name, <%=n%>$ObjectRef, 0, 0);
		JSStringRelease(<%=n%>$name);
<% }) -%>

		// variables
<% variables.forEach(function(v) { -%>
		<%- v %>
<% }) -%>

		// symbols
<% Object.keys(symbols).forEach(function(f) {
	Object.keys(symbols[f]).forEach(function(sym) {
		var symbol = symbols[f][sym];-%>

		JSStringRef <%=sym%>name = JSStringCreateWithUTF8CString("<%=sym%>");
		JSObjectRef <%=sym%>ObjectRef = JSObjectMakeFunctionWithCallback(contextRef,<%=sym%>name,<%=sym%>For<%=f%>);
    	JSObjectSetProperty(contextRef, globalObjectRef, <%=sym%>name, <%=sym%>ObjectRef, 0, 0);
		JSStringRelease(<%=sym%>name);
<% }) -%>
<% }) -%>

<% Object.keys(gen.constructors).forEach(function(c) { -%>
		// <%=gen.constructors[c].node.start.line%>:<%=gen.constructors[c].node.start.line%> => <%-: gen.constructors[c].source | source -%>

		object[@"<%=c%>$Class"] = globalObject[@"<%=c%>"];

<% }) -%>

<% Object.keys(gen.customclasses).forEach(function(c) {
		var classdef = gen.customclasses[c];
	-%>
		// <%=classdef.symbol %>
		//
		object[@"<%=classdef.symbol%>"] = ^(JSValue *callback) {
			JSContext *context = [JSContext currentContext];
			JSGlobalContextRef ctx = [context JSGlobalContextRef];
			JSValueRef callbackRef = [callback JSValueRef];
			JSObjectRef callbackObjRef = JSValueToObject(ctx, callbackRef, 0);
			JSObjectRef instance = MakeObjectFor<%=classdef.className%>Constructor(ctx,callbackObjRef);
			JSStringRef propStr = JSStringCreateWithUTF8CString("<%=classdef.className%>");
	    	JSObjectSetProperty(contextRef, globalObjectRef, propStr, instance, 0, 0);
	    	JSStringRelease(propStr);
		};
<% }) -%>

		//TODO: put this in global scope eventually and only do it once
		//TODO: check to see if we are tracking objects before doing this
		object[@"HL$TrackOwner"] = ^(JSValue *jsobject, JSValue *nativeobject) {
		};


		// turn our JS object into a dictionary so we can get the keys, values
		NSDictionary *dict = [object toDictionary];
		NSArray *keys = [dict allKeys];
		NSString *argStr = [keys componentsJoinedByString:@","];
		NSArray *values = [dict allValues];

		// make the common JS function wrapper, we pass in the variable names we're exposing to
		// the local scope and then will invoke the function with those values

    	NSString *commonJS = [NSString stringWithFormat:@"(function(%@){ %@ ; return exports; })", argStr, jscode];

		JSValue *jsValue = [context evaluateScript:commonJS];
		if (context.exception)
		{
			NSLog(@"[ERROR] syntax error loading file <%=gen.filename%>, %@",context.exception);
			return [JSValue valueWithUndefinedInContext:context];
		}
		JSValue *result = [jsValue callWithArguments:values];
		if (context.exception)
		{
			NSLog(@"[ERROR] syntax running <%=gen.filename%>, %@",context.exception);
			return [JSValue valueWithUndefinedInContext:context];
		}
		// stick the results of what we've exported into our cache so that when you attempt
		// to load the module again, you'll get the cached exports
		moduleCache[@"<%=gen.name%>"] = result;

		return result;
	}
}

@end
