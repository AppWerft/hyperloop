/**
 * Copyright (c) 2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 */

// WARNING: this file is generated and will be overwritten
// Generated on <%=new Date%>

#define UNUSED(x) (void)(x)

/**
 * JSC implementation for <%=entry.framework%>/<%=entry.name%>
 */
<%
	var readonly_properties = {},
		readwrite_properties = {},
        methods = {},
        properties_to_exclude = exclusions.properties,
        methods_to_exclude = exclusions.methods,
        varname = entry.name.toLowerCase(),
        ctor_readonly_properties = {},
        ctor_readwrite_properties = {},
        ctor_methods = {},
        ctor_properties_to_exclude = exclusions.properties,
        ctor_methods_to_exclude = exclusions.methods,
        instanceName = entry.name;

    // instance
    copyProperties(true,entry.properties,properties_to_exclude,methods_to_exclude,readonly_properties,readwrite_properties,imports,version,entry);
    copyMethods(true,entry.methods,methods,readonly_properties,readwrite_properties,methods_to_exclude,imports,version,entry,metadata);

    // constructor
    copyProperties(false,entry.properties,ctor_properties_to_exclude,ctor_methods_to_exclude,ctor_readonly_properties,ctor_readwrite_properties,imports,version,entry);
    copyMethods(false,entry.methods,ctor_methods,ctor_readonly_properties,ctor_readwrite_properties,ctor_methods_to_exclude,imports,version,entry,metadata);

    var superClass = metadata.classes[entry.superClass];
    if (superClass && externs.indexOf(entry.superClass)===-1) {
        externs.push(entry.superClass);
    }

    entry.protocols && entry.protocols.forEach(function(p){
        var pe = metadata.protocols[p];
        if (pe.framework && imports.indexOf(pe.framework)===-1) {
            imports.push(pe.framework);
        }
        // instance
        copyMethods(true,pe.methods,methods,readonly_properties,readwrite_properties,methods_to_exclude,imports,version,entry,metadata);
        copyProperties(true,pe.properties,properties_to_exclude,methods_to_exclude,readonly_properties,readwrite_properties,imports,version,entry);

        // constructor
        copyMethods(false,pe.methods,ctor_methods,ctor_readonly_properties,ctor_readwrite_properties,ctor_methods_to_exclude,imports,version,entry,metadata);
        copyProperties(false,pe.properties,ctor_properties_to_exclude,ctor_methods_to_exclude,ctor_readonly_properties,ctor_readwrite_properties,imports,version,entry);   
    });

    Object.keys(readonly_properties).forEach(function(k){
        delete readwrite_properties[k];
    });

-%>
#import "<%=entry.name%>.h"

JSClassDefinition ClassDefinitionFor<%=entry.name%>;
JSClassDefinition ClassDefinitionFor<%=entry.name%>Constructor;
JSClassRef <%=entry.name%>ClassDef;
JSClassRef <%=entry.name%>ClassDefForConstructor;

<% if (entry.superClass) { -%>
extern JSClassRef CreateClassFor<%=entry.superClass%>();
extern JSClassRef CreateClassFor<%=entry.superClass%>Constructor();
<% } -%>

<% Object.keys(readonly_properties).sort().forEach(function(p) {
    var property = readonly_properties[p];
-%>
/**
 * [<%=entry.name%> <%=p%>]
 */
JSValueRef Get<%=: p | capitalize %>For<%=entry.name%> (JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
    <%-generateReturnType(property.type,property.subtype,'prop',entry.name)%> = <%=varname%>.<%=p%>;
    UNUSED(prop);
    <%-generateJSCType(metadata,externs,makers,entry.name,property.type,property.subtype,'prop','result','    ',imports) %>
    return result;
}

<% }) -%>

<% Object.keys(readwrite_properties).sort().forEach(function(p) {
    var property = readwrite_properties[p],
        classtype = getClassType(metadata,property.type,property.subtype,entry.name,varname);
-%>
/**
 * [<%=entry.name%> <%=p%>]
 */
JSValueRef Get<%=: p | capitalize %>For<%=entry.name%> (JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
    <%-generateReturnType(property.type,property.subtype,'prop',entry.name)%> = <%=varname%>.<%=p%>;
    UNUSED(prop);
    <%-generateJSCType(metadata,externs,makers,entry.name,property.type,property.subtype,'prop','result','    ',imports) %>
    return result;
}

/**
 * [<%=entry.name%> <%=p%>:value]
 */
bool Set<%=: p | capitalize %>For<%=entry.name%> (JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
    UNUSED(<%=varname%>);

    if (JSValueIsObject(ctx,value))
    {
<% if (classtype.metatype === 'interface') { -%>
        JSObjectRef vo = JSValueToObject(ctx,value,exception);
        <%-property.type%> v = (<%-property.type%>)HyperloopGetPrivateObjectAsID(vo);
        <%=varname%>.<%=p%> = v;
<% } else if (classtype.metatype === 'primitive') { -%>
        double v = JSValueToNumber(ctx,value,exception);
        <%=varname%>.<%=p%> = (<%-property.type%>)v;
<% } else if (classtype.metatype === 'enum') { -%>
        double v = JSValueToNumber(ctx,value,exception);
        <%=varname%>.<%=p%> = (<%-property.type%>)v;
<% } else if (classtype.metatype === 'struct') { -%>
        <%-structFromObject(metadata,classtype,'value','value$','        ')%>
        <%=varname%>.<%=p%> = value$;
<% } %>
    }
    return true;
}
<% }) -%>

<% Object.keys(methods).sort().forEach(function(m) {
    var ma = methods[m];
-%>
/**
 * [<%=entry.name%> <%=ma[0].selector%>]
 */
JSValueRef <%=m%>For<%=entry.name%> (JSContextRef ctx, JSObjectRef function, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
<% ma.forEach(function(method) { -%>
    // <%-method.selector%>
    if (argumentCount == <%=method.args.length%>)
    {
        <%-generateInvocation(metadata,externs,makers,entry,method,varname,m,'        ',true,imports)%>
    }
<% });-%>
    <%-makeException('    ','invalid number of arguments passed') %>
}

<% });-%>

/**
 * generic conversion from native object representation to JS string
 */
JSValueRef toStringFor<%=entry.name%> (JSContextRef ctx, JSObjectRef function, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
    return HyperloopToString(ctx, <%=varname%>);
}

static JSStaticValue StaticValueArrayFor<%=entry.name%> [] = {
<% Object.keys(readonly_properties).sort().forEach(function(p) { -%>
    { "<%=p%>", Get<%=: p | capitalize %>For<%=entry.name%>, 0, kJSPropertyAttributeReadOnly },
<% }) -%>
<% Object.keys(readwrite_properties).sort().forEach(function(p) { -%>
    { "<%=p%>", Get<%=: p | capitalize %>For<%=entry.name%>, Set<%=: p | capitalize %>For<%=entry.name%>, kJSPropertyAttributeNone },
<% }) -%>
    { 0, 0, 0, 0 }
};

static JSStaticFunction StaticFunctionArrayFor<%=entry.name%> [] = {
<% Object.keys(methods).sort().forEach(function(m) {  -%>
    { "<%=m%>", <%=m%>For<%=entry.name%>, kJSPropertyAttributeNone },
<% }) -%>
    { "toString", toStringFor<%=entry.name%>, kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontEnum | kJSPropertyAttributeDontDelete },
    { 0, 0, 0 }
};

JSObjectRef <%=entry.name%>MakeInstance (JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
<% if (hasMethodPrototype(metadata,entry,'init')) { %>
    <%=instanceName%> *instance = [[<%=instanceName%> alloc] init];
<% } else { %>
    <%=instanceName%> *instance = [<%=instanceName%> alloc];
<% } %>
<% } else { -%>
    id instance = nil;
<% } -%>
    JSObjectRef object = MakeObjectFor<%=entry.name%>(ctx,instance);
    return object;
}

/**
 * called to make an instance of the <%=entry.name%> class using the proper
 * constructor and prototype chain.  this is called when you call
 * new <%=entry.name%>()
 */
JSObjectRef MakeInstanceFor<%=entry.name%> (JSContextRef ctx, JSObjectRef constructor, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    return <%=entry.name%>MakeInstance(ctx,argumentCount,arguments,exception);
}

/**
 * called to make an instance of the <%=entry.name%> class using the proper
 * constructor and prototype chain. this is called when you call
 * <%=entry.name%>()
 */
JSValueRef MakeInstanceFromFunctionFor<%=entry.name%> (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    return <%=entry.name%>MakeInstance(ctx,argumentCount,arguments,exception);
}

/**
 * called when a new JS object is created for this class
 */
void InitializerFor<%=entry.name%> (JSContextRef ctx, JSObjectRef object)
{
}

/**
 * called when the JS object is ready to be garbage collected
 */
void FinalizerFor<%=entry.name%> (JSObjectRef object)
{
    HyperloopDestroyPrivateObject(object);
}

/**
 * type conversion from native type to JS type
 */
JSValueRef JSTypeConvertorFor<%=entry.name%>(JSContextRef ctx, JSObjectRef object, JSType type, JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
    if (type == kJSTypeString) 
    {
        NSString *description = [<%=varname%> description];
        JSStringRef descriptionStr = JSStringCreateWithUTF8CString([description UTF8String]);
        JSValueRef result = JSValueMakeString(ctx, descriptionStr);
        JSStringRelease(descriptionStr);
        return result;
    }
    else
    {
        double value = 0;
        if ([<%=varname%> isKindOfClass:[NSNumber class]])
        {
            value = [((NSNumber*)<%=varname%>) doubleValue];
        }
        else
        {
            NSString *description = [<%=varname%> description];
            NSNumberFormatter *numberFormatter = [[NSNumberFormatter alloc] init];
            [numberFormatter setNumberStyle:NSNumberFormatterDecimalStyle];
            value = [[numberFormatter numberFromString:description] doubleValue];
            [numberFormatter release];
        }
        return JSValueMakeNumber(ctx, value);
    }
    return NULL;
}

/**
 * called to determine if an object is of a subclass
 */
bool IsInstanceFor<%=entry.name%> (JSContextRef ctx, JSObjectRef constructor, JSValueRef possibleInstance, JSValueRef* exception)
{
    if (HyperloopPrivateObjectIsType(constructor,JSPrivateObjectTypeID) &&
        HyperloopPrivateObjectIsType((JSObjectRef)possibleInstance,JSPrivateObjectTypeID))
    {
        id constructorObj = HyperloopGetPrivateObjectAsID(constructor);
        id possibleSubclassObj = HyperloopGetPrivateObjectAsID((JSObjectRef)possibleInstance);

        return [possibleSubclassObj isKindOfClass:[constructorObj class]];
    }
    return false;
}

<% Object.keys(ctor_methods).sort().forEach(function(m) {
    var ma = ctor_methods[m];
-%>
/**
 * [<%=entry.name%> <%=ma[0].name%>]
 */
JSValueRef <%=m%>For<%=entry.name%>Constructor (JSContextRef ctx, JSObjectRef function, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
<% if (entry.metatype==='interface') { -%>
    <%-entry.name%> *<%=varname%> = (<%=entry.name%>*)HyperloopGetPrivateObjectAsID(object);
<% } else { -%>
    id<<%-entry.name%>> <%=varname%> = (id<<%=entry.name%>>)HyperloopGetPrivateObjectAsID(object);
<% } -%>
<% ma.forEach(function(method) { 
    var oldName = entry.name;
    entry.name+='Class';
-%>
    // <%-method.selector%>
    if (argumentCount == <%=method.args.length%>)
    {
        <%-generateInvocation(metadata,externs,makers,entry,method,instanceName,m,'        ',true,imports)%>
    }
<% entry.name = oldName;
});-%>
    <%-makeException('    ','invalid number of arguments passed') %>
}

<% });-%>

static JSStaticFunction StaticFunctionArrayFor<%=entry.name%>Constructor [] = {
<% Object.keys(ctor_methods).sort().forEach(function(m) {  -%>
    { "<%=m%>", <%=m%>For<%=entry.name%>Constructor, kJSPropertyAttributeNone },
<% }) -%>
    { 0, 0, 0 }
};

/**
 * called to get the JSClassRef for <%=entry.name%> constructor class
 */
JSClassRef CreateClassFor<%=entry.name%>Constructor ()
{
    static bool init;
    if (!init)
    {
        init = true;

        ClassDefinitionFor<%=entry.name%>Constructor = kJSClassDefinitionEmpty;
        ClassDefinitionFor<%=entry.name%>Constructor.className = "<%=entry.name%>Constructor";
        ClassDefinitionFor<%=entry.name%>Constructor.callAsConstructor = MakeInstanceFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>Constructor.callAsFunction = MakeInstanceFromFunctionFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>Constructor.staticFunctions = StaticFunctionArrayFor<%=entry.name%>Constructor;

    <% if (entry.superClass) { -%>
    ClassDefinitionFor<%=entry.name%>Constructor.parentClass = CreateClassFor<%=entry.superClass%>Constructor();
    <% } -%>
    <%=entry.name%>ClassDefForConstructor = JSClassCreate(&ClassDefinitionFor<%=entry.name%>Constructor);

        JSClassRetain(<%=entry.name%>ClassDefForConstructor);
    }
    return <%=entry.name%>ClassDefForConstructor;
}

/**
 * called to get the JSClassRef for <%=entry.name%> class
 */
JSClassRef CreateClassFor<%=entry.name%> ()
{
    static bool init;
    if (!init)
    {
        init = true;

        ClassDefinitionFor<%=entry.name%> = kJSClassDefinitionEmpty;
        ClassDefinitionFor<%=entry.name%>.staticValues = StaticValueArrayFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>.staticFunctions = StaticFunctionArrayFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>.initialize = InitializerFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>.finalize = FinalizerFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>.convertToType = JSTypeConvertorFor<%=entry.name%>;
        ClassDefinitionFor<%=entry.name%>.className = "<%=entry.name%>";
        ClassDefinitionFor<%=entry.name%>.hasInstance = IsInstanceFor<%=entry.name%>;

    <% if (entry.superClass) { -%>
    ClassDefinitionFor<%=entry.name%>.parentClass = CreateClassFor<%=entry.superClass%>();
    <% } -%>
    <%=entry.name%>ClassDef = JSClassCreate(&ClassDefinitionFor<%=entry.name%>);

        JSClassRetain(<%=entry.name%>ClassDef);
    }
    return <%=entry.name%>ClassDef;
}

/**
 * called to make a native object for <%=entry.name%>. this method must be called instead of
 * normal JSObjectMake in JavaScriptCore so that the correct prototype chain and
 * constructor will be setup.
 */
<% if (entry.metatype==='interface') { -%>
JSObjectRef MakeObjectFor<%=entry.name%> (JSContextRef ctx, <%=entry.name%> *instance) 
<% } else { -%>
JSObjectRef MakeObjectFor<%=entry.name%> (JSContextRef ctx, id<<%=entry.name%>> instance) 
<% } -%>
{
    JSObjectRef object = JSObjectMake(ctx, CreateClassFor<%=entry.name%>(), (void*)HyperloopMakePrivateObjectForID(instance));
    JSObjectRef value = JSObjectMake(ctx, CreateClassFor<%=entry.name%>Constructor(), 0);

    JSStringRef cproperty = JSStringCreateWithUTF8CString("constructor");
    JSObjectSetProperty(ctx, object, cproperty, value, kJSPropertyAttributeDontEnum, 0);
    JSStringRelease(cproperty);

    JSStringRef nameProperty = JSStringCreateWithUTF8CString("name");
    JSStringRef valueProperty = JSStringCreateWithUTF8CString("<%=entry.name%>");
    JSValueRef valueRef = JSValueMakeString(ctx, valueProperty);
    JSObjectSetProperty(ctx, value, nameProperty, valueRef, kJSPropertyAttributeDontEnum, 0);
    JSStringRelease(nameProperty);
    JSStringRelease(valueProperty);

    return object;
}

/**
 * called to make a native object for <%=entry.name%>. this method must be called instead of
 * normal JSObjectMake in JavaScriptCore so that the correct prototype chain and
 * constructor will be setup.
 */
JSObjectRef MakeObjectFor<%=entry.name%>Constructor (JSContextRef ctx)
{
    JSClassRef classRef = CreateClassFor<%=entry.name%>Constructor();
    JSObjectRef object = JSObjectMake(ctx, classRef, 0);

    JSStringRef nameProperty = JSStringCreateWithUTF8CString("name");
    JSStringRef valueProperty = JSStringCreateWithUTF8CString("<%=entry.name%>");
    JSValueRef valueRef = JSValueMakeString(ctx, valueProperty);
    JSObjectSetProperty(ctx, object, nameProperty, valueRef, kJSPropertyAttributeDontEnum, 0);
    JSStringRelease(nameProperty);
    JSStringRelease(valueProperty);

    JSObjectRef plainObject = JSObjectMake(ctx,0,0);
    JSStringRef prototypeProperty = JSStringCreateWithUTF8CString("prototype");
    JSObjectSetProperty(ctx, object, prototypeProperty, plainObject, kJSPropertyAttributeDontEnum, 0);
    JSStringRelease(prototypeProperty);

    JSStringRef cproperty = JSStringCreateWithUTF8CString("constructor");
    JSObjectSetProperty(ctx, plainObject, cproperty, object, kJSPropertyAttributeDontEnum, 0);
    JSStringRelease(cproperty);

    return object;
}

/**
 * utility class for generating a JSObjectRef wrapper
 */
@implementation <%=entry.name%>Factory

+(JSObjectRef)make:(JSContextRef)ctx instance:(id)instance
{
    return MakeObjectFor<%=entry.name%>(ctx, (<%=entry.name%>*)instance);
}

@end

