/**
 * Copyright (c) 2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 */

// WARNING: this file is generated and will be overwritten
// Generated on <%=new Date%>

#import "<%=framework%>_globals.h"

#define UNUSED(x) (void)(x)

/**
 * JSC implementation for <%=framework%> globals
 */

<% symbols.forEach(function(symbol) { %>
JSValueRef <%- symbol.name %>For<%=framework%> (JSContextRef ctx, JSObjectRef function, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception) 
{
<%	if (!symbol.formatter) { -%>
	if (argumentCount!=<%=symbol.arguments.length%>)
	{
	    <%-makeException('	    ','invalid number of arguments passed, expected '+symbol.arguments.length) %>
	}
<%  } -%>
<%  var index = 0, cleanup = [], args = [],  outargs = [],
		returnsType = (symbol.returnType==='void') ? '' : (symbol.returnType + ' value = '),
		formatPosition = symbol.formatter && parseInt(symbol.formatter.position);

	symbol.arguments.forEach(function(arg) { 
		var gen = generateObjCType(metadata,arg.type,arg.subtype,'',arg.name+'ValueRef',arg.name+'$','	',imports);
		var cast = gen.cast ? '('+ (gen.cast) + ')' : '('+arg.subtype+')';
		args.push(cast + (gen.use_pointer ? '&':'')+arg.name+'$');
		gen.cleanup && cleanup.push(gen.cleanup);
		if (gen.use_pointer && !returnsType) {
			// this is an out pointer, so we want to return a result object with out parameters
			// for now this is OK, but we likely will want to create a special object type
			// that the compiler understands and can wrap the inout object and unwrap it back
			// after invocation
			outargs.push(arg.name+'$');
		}
-%>
	JSValueRef <%=arg.name%>ValueRef = arguments[<%=index++%>];
	UNUSED(<%=arg.name%>ValueRef);
	<%-gen.code%>
<%  }) -%>
<%	if (!symbol.formatter) { -%>
	<%-returnsType%><%=symbol.name%>(<%-args.join(', ')%>);
<%  } else { -%>
	
	<%-returnsType ? returnsType+' NULL;':''%>

	// dynamic formatter
	switch(argumentCount) 
	{
	<% 	var ft = symbol.formatter.type;
		if (ft==='NSString') ft+=' *';
		for (var c=formatPosition;c<formatPosition+5;c++) { %>		
		case <%=c+1%>: 
		{<%
			var g = generateDynamicArg(metadata,ft,ft,'','arguments','result'+c,'			',args,formatPosition,c-formatPosition,imports);
			g.cleanup && cleanup.concat(g.cleanup);
		-%>

			<%-g.code%>
			<%-returnsType?'value':''%><%=symbol.name%>(<%-g.args.join(', ')%>);
			break;
		}
	<% } -%>		

	}
<%  } -%>
	<%-cleanup%>
<% 	if (returnsType) { -%>
	UNUSED(value); // <%=symbol.returnType%>
	<%-generateJSCType(metadata,externs,makers,symbol.name,symbol.returnType,symbol.returnSubtype,'value','result','	') %>
<%  } else if (outargs.length) { -%>
	// out parameters so we're going to return them in the order passed back as an array
	JSValueRef array [<%=outargs.length%>];
	size_t len = <%=outargs.length%>;
<%  for (var i=0;i<outargs.length;i++) { -%>
	array[<%=i%>] = JSValueMakeNumber(ctx,<%=outargs[i]%>);
<%  } %>	
	JSObjectRef result = JSObjectMakeArray(ctx,len,array,0);
<%  } else { -%>
	JSValueRef result = JSValueMakeUndefined(ctx);
<%  } -%>

	return result;
}

<% }) %>
