/**
 * @preserve This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 * 
 * WARNING: this file is generated and will be overwritten
 * It was generated from <%=gen.filename%> on <%=new Date%>
 */
@import JavaScriptCore;
<% gen.imports.forEach(function(p) { -%>
@import <%=p%>;
<% }) -%>
<% gen.includes.forEach(function(h) { -%>
#import <<%=h%>>
<% }) -%>
#import "types.h"

// implementations define this
extern NSData* decompressBuffer (NSData*);

// defined in types.m
extern void <%=gen.registerFunctionName%>();

@protocol <%=gen.prefix%>CallbackExport <JSExport>
-(id) selector;
@end

@interface <%=gen.prefix%>Callback : NSObject<<%=gen.prefix%>CallbackExport>
-(id)initWithCallback:(JSValue*)value;
@end

@interface JSValue(SEL)
+(JSValue*)valueWithSelector:(SEL)selector inContext:(JSContext*)context;
-(SEL)toSelector;
@end

@implementation JSValue(SEL)

+(JSValue*)valueWithSelector:(SEL)selector inContext:(JSContext*)context
{
	NSDictionary *dict = @{@"metatype":@"selector", @"selector": NSStringFromSelector(selector)};
	JSValue *result = [JSValue valueWithObject:dict inContext:context];
	return result;
}

-(SEL)toSelector {
	id object = [self toObject];
	if ([object isKindOfClass:[NSDictionary class]]) 
	{
		NSString *selector = [object objectForKey:@"selector"];
		return NSSelectorFromString(selector);
	}
	else 
	{
		return NSSelectorFromString((NSString*)object);
	}
}
@end

@interface Foo : NSObject
-(void)action:(id)sender;
@end


@interface <%=gen.prefix%><%=gen.name%> : NSObject
+(JSValue*)load:(JSContext*)context;
@end

@implementation <%=gen.prefix%><%=gen.name%> 

+(NSData*)buffer
{
	static UInt8 data[] = { 
		<%=gen.jsBuffer %> 
	};
	return [NSData dataWithBytes:((void*)data) length:<%=gen.jsBuffer.length%>];
}

+(JSValue*)load:(JSContext*)context
{
	static NSMutableDictionary *storage;

	if (storage==nil)
	{
	 	storage = [[NSMutableDictionary alloc] init];	
	}

	@autoreleasepool 
	{
		<%=gen.registerFunctionName%>();

		JSValue *globalObject = [context globalObject];

		// holds a dictionary of all our loaded modules
		JSValue *moduleCache = globalObject[@"$modules"];
		if (moduleCache==nil || ![moduleCache isObject])
		{
			moduleCache = [JSValue valueWithNewObjectInContext:context];
		    [globalObject defineProperty:@"$modules" descriptor:@{
		       JSPropertyDescriptorValueKey: moduleCache,
		       JSPropertyDescriptorWritableKey: @NO,
		       JSPropertyDescriptorEnumerableKey: @NO,
		       JSPropertyDescriptorConfigurableKey: @YES
		    }];
		}
		else 
		{
			// if we're trying to load again, we always must return
			// the same reference to the module exports
			JSValue *result = moduleCache[@"<%=gen.name%>"];
			if (result!=nil && [result isObject])
			{
				return result;
			}
		}

		JSValue *object = [JSValue valueWithNewObjectInContext:context];
		NSData *compressedBuf = [<%=gen.prefix%><%=gen.name%> buffer];
		NSString *jscode;
		if ([compressedBuf length]==1) 
		{
			// if empty, just evaluate empty JS string
			jscode = @"";
		}
		else 
		{
			NSData *buffer = decompressBuffer(compressedBuf);
	    	jscode = [[NSString alloc] initWithData:buffer encoding:NSUTF8StringEncoding];
		}
    	JSValue *module = [JSValue valueWithNewObjectInContext:context];
    	JSValue *exports = [JSValue valueWithNewObjectInContext:context];

    	object[@"module"] = module;
    	// module.exports is an alias to exports
    	object[@"exports"] = exports;
    	object[@"__dirname"] = @"<%=gen.dirname%>";
    	object[@"__filename"] = @"<%=gen.filename%>";

    	// relative require implementation which takes into account this modules path
    	// so you can relatively load a module
    	id (^require)(NSString *) = ^(NSString *path)
    	{
    		if ([path hasPrefix:@"./"])
    		{
    			path = [NSString stringWithFormat:@"<%=gen.dirname%>%@",[path substringFromIndex:2]];
    		}
    		if ([path hasPrefix:@"/"])
    		{
    			path = [path substringFromIndex:1];
    		}
<% if (gen.dirname!=='/') { -%>
			if ([path hasPrefix:@"<%=gen.dirname%>"]==NO) 
			{
<% if (gen.dirname.charAt(0)==='/') { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname.substring(1)%>/%@", path];
<% } else { -%>
				path = [NSString stringWithFormat:@"<%=gen.dirname%>/%@", path];
<% } %>			}
<% } %>			   		
    		NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"[\\s-\\/]" options:NSRegularExpressionCaseInsensitive error:nil];
    		NSString *cn = [regex stringByReplacingMatchesInString:path options:0 range:NSMakeRange(0, [path length]) withTemplate:@"_"];
    		Class cls = NSClassFromString([NSString stringWithFormat:@"<%=gen.prefix%>%@",cn]);
    		if (cls==nil) 
    		{
    			NSString *err = [NSString stringWithFormat:@"couldn't find module named: %@",path];
    			[JSContext currentContext].exception = [JSValue valueWithNewErrorFromMessage:err inContext:[JSContext currentContext]];
    			NSLog(@"[ERROR] %@",err);
    			return (id)nil;
    		}
    		return [cls performSelector:@selector(load:) withObject:context];
    	};	

    	// make our local require function as part of what we're going to expose local scope
    	object[@"require"] = require;

    	module[@"exports"] = exports;
    	module[@"filename"] = @"<%=gen.filename%>";
    	module[@"id"] = @"<%=gen.name%>";

    	object[@"invoke$$"] = ^() {
    		NSArray *arguments = [JSContext currentArguments];
    		if ([arguments count] < 2) {
    			JSContext *context = [JSContext currentContext];
    			context.exception = [JSValue valueWithNewErrorFromMessage:@"invalid arguments passed to invoke$$" inContext:context];
    			return [JSValue valueWithUndefinedInContext:context];
    		}
    		JSValue *instance = [arguments objectAtIndex:0];
    		id instanceObj = [instance toObject];
    		JSValue *selector = [arguments objectAtIndex:1];
    		SEL selectorObj = [selector toSelector];
    		JSValue *target = [arguments objectAtIndex:2];
    		id targetObj = [target toObject];

    		NSMethodSignature *method = [instanceObj methodSignatureForSelector:selectorObj];
    		NSInvocation *invoke = [NSInvocation invocationWithMethodSignature:method];
    		[invoke setTarget:instanceObj];
    		[invoke setSelector:selectorObj];
    		for (int i=2;i<[arguments count];i++) {
    			JSValue *value = [arguments objectAtIndex:i];
    			id valueObj = [value toObject];
    			[invoke _setArgument:valueObj atIndex:i];
    		}
    		[invoke invoke];
    		id result = [invoke _returnValue];
    		return [JSValue valueWithObject:result inContext:[JSContext currentContext]];
    	};

    	// create a function that will generate callback objects
    	object[@"createCallback$$"] = ^(JSValue *fn) {
    		<%=gen.prefix%>Callback *callback = [[<%=gen.prefix%>Callback alloc] initWithCallback:fn];
    		//TODO: need a better way to manage memory with ARC
    		NSString *cbKey = [NSString stringWithFormat:@"%p",callback];
    		NSString *fnKey = [NSString stringWithFormat:@"%p",fn];
    		[storage setObject:callback forKey:cbKey];
    		[storage setObject:fn forKey:fnKey];
    		return callback;
    	};

<% var mapvarargfns = []; -%>
<% Object.keys(gen.statics).forEach(function(s) { -%>
		<%if (!gen.statics[s].ref.vararg) { %>

		// <%=gen.statics[s].node.start.line%>:<%=gen.statics[s].node.start.line%> => <%-: gen.statics[s].source | source -%>
		object[@"<%=s%>"] = <%=gen.generateStatic(gen.ast,gen.statics[s],'		')%>;
		<% } else { -%>

		// <%=gen.statics[s].node.start.line%>:<%=gen.statics[s].node.start.line%> => <%- gen.statics[s].source %>
		object[@"<%=s%>"] = ^{
			NSArray *args = [JSContext currentArguments];
<% Object.keys(gen.functions).forEach(function(f) { -%>
<% var fns = gen.functions[f];  fns.forEach(function(fn) { -%>
	<% if (fn.varargSymbol && fn.varargSymbol.indexOf(s+'$')===0 && mapvarargfns.indexOf(fn.varargSymbol)===-1) { -%>
		<% mapvarargfns.push(fn.varargSymbol); -%>

			// vardiac function with <%= fn.varargCount %> arguments
			if ([args count]==<%=fn.varargCount%>) 
			{
				<%= fn.varargResult ? 'return ' : ''%> <%= f %>(<%= gen.currentArgument(fn.varargCount,'args') %>);
			}
	<% } -%>
<% }) -%>
<% }) -%>
	};
		<% } -%>
<% }) -%>
<% Object.keys(gen.classes).forEach(function(c) { %>
		// <%=gen.classes[c].node.start.line%>:<%=gen.classes[c].node.start.line%> => <%-: gen.classes[c].source | source -%>
		object[@"<%=c%>"] = [<%=c%> class];

<% }) -%>
<% Object.keys(gen.constructors).forEach(function(c) { -%>
		// <%=gen.constructors[c].node.start.line%>:<%=gen.constructors[c].node.start.line%> => <%-: gen.constructors[c].source | source -%>
		object[@"<%=c%>"] = ^{
			return [[<%=c%> alloc] init];
		};
	
<% }) -%>

		// turn our JS object into a dictionary so we can get the keys, values
		NSDictionary *dict = [object toDictionary];
		NSArray *keys = [dict allKeys];
		NSString *argStr = [keys componentsJoinedByString:@","];
		NSArray *values = [dict allValues];

		// make the common JS function wrapper, we pass in the variable names we're exposing to
		// the local scope and then will invoke the function with those values
    	NSString *commonJS = [NSString stringWithFormat:@"(function(%@){ %@ ; return exports; })", argStr, jscode];
		JSValue *jsValue = [context evaluateScript:commonJS];
		JSValue *result = [jsValue callWithArguments:values];

		// stick the results of what we've exported into our cache so that when you attempt
		// to load the module again, you'll get the cached exports
		moduleCache[@"<%=gen.name%>"] = result;

		return result;
	}
}

@end
